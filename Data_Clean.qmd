---
bibliography: references.bib
---

### Loading and Exploring the Data
```{r}
library(tidyverse); theme_set(theme_bw())

path1 <- "Data\\2016-2021-imi-results-long-view.csv"
path2 <- "Data\\data2.csv"
path3 <- "Data\\2020census.csv"

data1 <- read_csv(path1)
data2 <- read_csv(path2)
data3 <- read_csv(path3)
```

```{r}
head(data1)
head(data2)
head(data3)
```

```{r}
# names(data1)
# names(data2)
# names(data3)
```


#### Cleaning Data Set 1

From data set 1, let's drop the geographic variables (since they're redundant when `County` is in the data set).

```{r}
names(data1) <- c("Year", "County", "Hospital", "OSHPDID", "Procedure", "AdjMortRate", "Deaths", "Cases", "HospitalRating", "Longitude", "Latitude")
kept_cols <- c("Year", "County", "Hospital", "OSHPDID", "Procedure", "AdjMortRate", "Deaths", "Cases", "HospitalRating")
data1 <- data1[, kept_cols]
glimpse(data1)
```

Let's keep observations from data set 1 only if they come from a county which exists in the second data set.
```{r}
data1_counties <- unique(data1$County)
data2_counties <- sort(unique(data2$counties))

# all(data1_counties[data1_counties %in% data2_counties] == data2_counties[data2_counties %in% data1_counties])
common_counties <- data1_counties[data1_counties %in% data2_counties]
common_counties[1:5]

data1 %>% 
  filter(County %in% common_counties) -> data1

data1$AdjMortRate <- ifelse(data1$AdjMortRate == ".", NA, data1$AdjMortRate)
data1$AdjMortRate <- as.numeric(data1$AdjMortRate)
data1$Deaths <- ifelse(data1$Deaths == ".", NA, data1$Deaths)
data1$Deaths <- as.numeric(data1$Deaths)

unique(data1$Procedure)
```

```{r}
data1 %>% 
	group_by(County, HospitalRating) %>% 
	filter(Procedure == "Heart Failure") %>% 
	summarize(Total_Mort = sum(AdjMortRate), Total_Deaths = sum(Deaths)) -> data1_heart
```


#### Cleaning Data Set 2

Again, let's keep observations from data set 2 only if they come from a county which exists in the first data set.
```{r}
data2 %>% 
  filter(counties %in% common_counties) -> data2
```


#### Cleaning Data Set 3

`AvgHouseholdMems`, `AvgFamilyMems`, `18` and `21` are entirely empty, so we will remove all of those variables. `Geoid` also does not contain any useful information not explained by Geography.

```{r}
names(data3) <- c("Geography", "TotalPop", "MalePop", "FemalePop", "MedianAge", "MaleMedianAge", "FemaleMedianAge", "AvgHouseholdMems", "AvgFamilyMems", "Under5yoPop", "Under18yoPop", "Pop21andOlder", "Pop55andOlder", "Pop60andOlder", "Pop65andOlder", "PercFemale", "PercUnder18yo", "18", "Geoid", "21")

kept_cols <- c("Geography", "TotalPop", "MalePop", "FemalePop", "MedianAge", "MaleMedianAge", "FemaleMedianAge", "Under5yoPop", "Under18yoPop", "Pop21andOlder", "Pop55andOlder", "Pop60andOlder", "Pop65andOlder", "PercFemale", "PercUnder18yo")
data3 <- data3[, kept_cols]

glimpse(data3)
```

*Re-coding variables to their correct data type*

Several variables in the census data set use `"-"` as a placeholder observation for no data, which forces the entire data to take on the character string type. We can replace this entry with `NA` and then try to coerce the variable to a numeric type.
```{r}
unique(data3$MedianAge)

data3$MedianAge[data3$MedianAge == '-'] <- NA
data3$MedianAge <- as.numeric(data3$MedianAge)
# data3$MedianAge

data3$MaleMedianAge[data3$MaleMedianAge == '-'] <- NA
data3$MaleMedianAge <- as.numeric(data3$MaleMedianAge)

data3$FemaleMedianAge[data3$FemaleMedianAge == '-'] <- NA
data3$FemaleMedianAge <- as.numeric(data3$FemaleMedianAge)
```


This unfortunately does not work for two variables, where percent signs have been appended to the numbers. Luckily, a quick regex pass can both remove the percent signs and replace the `"-"` entries with `NA`s.

```{r}
unique(data3$PercUnder18yo)[1:10]
```

```{r}
string <- "24.5%"
# string <- NA
expression <- "(\\d{2}\\.\\d)"
as.numeric(str_extract(string, expression))
```

```{r}
expression <- "(\\d{1,3}\\.\\d)"

temp <- double(length(data3$PercUnder18yo))
for (i in seq_along(data3$PercUnder18yo)){
	temp[i] <- as.double(str_extract(data3$PercUnder18yo[i], expression))
}

data3$PercUnder18yo <- temp

temp <- double(length(data3$PercFemale))
for (i in seq_along(data3$PercFemale)){
	temp[i] <- as.double(str_extract(data3$PercFemale[i], expression))
}

data3$PercFemale <- temp
```

```{r}
expression <- "(.*) County"
data3_counties <- data3[str_detect(data3$Geography, expression),]
names(data3_counties)[1] <- "County"

expression <- "(.*) County"
data3_counties$County <- str_match(data3_counties$County, expression)[,2]

head(data3_counties)
```


```{r}
#| tbl-cap: "Dimensions of data sets after cleaning"

data_dims <- tibble(
	"Dimension" = c("Rows", "Columns"),
	"Data1" = dim(data1), 
	"Data2" = dim(data2), 
	"Data3" = dim(data3_counties)
) 
data_dims %>% knitr::kable()
```


```{r}
#| eval: false
write_csv(data1, ".\\Data\\data1_clean.csv")
write_csv(data2, ".\\Data\\data2_clean.csv")
write_csv(data3_counties, ".\\Data\\data3_counties.csv")
write_csv(data1_heart, ".\\Data\\data1_heart.csv")
```


### Joining Data

#### Preparing the Classification Data Set

```{r}
# Goal is to have final data into a rectangular tibble with no/few NAs
class_data_final = tibble()
```


#### Preparing the Regression Data Set

```{r}
data1_heart <- read_csv(".\\Data\\data1_heart.csv")
data2 <- read_csv(".\\Data\\data2_clean.csv")
data3_counties <- read_csv(".\\Data\\data3_counties.csv")

names(data2)[names(data2) == 'counties'] <- "County"
data2 %>% 
	group_by(County, hpsa_status) %>% 
	select(rural_status, per_pov, med_hh) -> data2hpsa
```



```{r}
# Want two new variables for every county: number of withdrawn HPSA hospitals, and num of active HSPA hospitals

data2hpsa %>% 
	group_by(County) %>% 
	filter(hpsa_status == "Withdrawn") %>% 
	count() -> data2withdr
data2hpsa %>% 
	group_by(County) %>%
	filter(hpsa_status != "Withdrawn") %>% 
	count() -> data2desig

```


```{r}
data1 %>% 
  filter(!is.na(HospitalRating)) %>% 
  group_by(County, HospitalRating) %>% 
  summarise(count = n())
```

```{r}
data1_heart %>% 
	left_join(data2, by = "County") %>% 
	left_join(data3_counties, by = "County") -> data123
data123
```


```{r}
# Goal is to have final data into a rectangular tibble with no/few NAs
reg_data_final = tibble()
```
